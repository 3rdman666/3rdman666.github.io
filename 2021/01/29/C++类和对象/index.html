<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++," />










<meta name="description" content="C++面向对象的三大特性为：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如： ​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记-类和对象">
<meta property="og:url" content="http://example.com/2021/01/29/C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="3rdman666&#39;s Blog">
<meta property="og:description" content="C++面向对象的三大特性为：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如： ​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…">
<meta property="og:locale">
<meta property="article:published_time" content="2021-01-29T11:43:32.000Z">
<meta property="article:modified_time" content="2021-01-29T05:33:38.048Z">
<meta property="article:author" content="3rdman666">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2021/01/29/C++类和对象/"/>





  <title>C++笔记-类和对象 | 3rdman666's Blog</title>
  








<meta name="generator" content="Hexo 5.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">3rdman666's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="3rdman666's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++笔记-类和对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-29T19:43:32+08:00">
                2021-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>C++面向对象的三大特性为：封装、继承、多态</p>
<p>C++认为万事万物都皆为对象，对象上有其属性和行为</p>
<p>例如：</p>
<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<a id="more"></a>
<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​ 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类</p>
<h1 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h1><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制<br>封装意义一：</li>
</ul>
<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>
<p>语法： <code>class 类名&#123; 访问权限： 属性 / 行为 &#125;;</code></p>
<p>示例1：设计一个圆类，求圆的周长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;圆周率</span><br><span class="line">const double PI &#x3D; 3.14;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1、封装的意义</span><br><span class="line">&#x2F;&#x2F;将属性和行为作为一个整体，用来表现生活中的事物</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;封装一个圆类，求圆的周长</span><br><span class="line">&#x2F;&#x2F;class代表设计一个类，后面跟着的是类名</span><br><span class="line">class Circle</span><br><span class="line">&#123;</span><br><span class="line">public:  &#x2F;&#x2F;访问权限  公共的权限</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;属性</span><br><span class="line">	int m_r;&#x2F;&#x2F;半径</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;行为</span><br><span class="line">	&#x2F;&#x2F;获取到圆的周长</span><br><span class="line">	double calculateZC()</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;2 * pi  * r</span><br><span class="line">		&#x2F;&#x2F;获取圆的周长</span><br><span class="line">		return  2 * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;通过圆类，创建圆的对象</span><br><span class="line">	&#x2F;&#x2F; c1就是一个具体的圆</span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r &#x3D; 10; &#x2F;&#x2F;给圆对象的半径 进行赋值操作</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2 * pi * 10 &#x3D; &#x3D; 62.8</span><br><span class="line">	cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;学生类</span><br><span class="line">class Student &#123;</span><br><span class="line">public:</span><br><span class="line">	void setName(string name) &#123;</span><br><span class="line">		m_name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	void setID(int id) &#123;</span><br><span class="line">		m_id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void showStudent() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string m_name;</span><br><span class="line">	int m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.setName(&quot;德玛西亚&quot;);</span><br><span class="line">	stu.setID(250);</span><br><span class="line">	stu.showStudent();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装意义二：</p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ul>
<li>public 公共权限</li>
<li>protected 保护权限</li>
<li>private 私有权限<br>示例代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;三种权限</span><br><span class="line">&#x2F;&#x2F;公共权限  public     类内可以访问  类外可以访问</span><br><span class="line">&#x2F;&#x2F;保护权限  protected  类内可以访问  类外不可以访问</span><br><span class="line">&#x2F;&#x2F;私有权限  private    类内可以访问  类外不可以访问</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;姓名  公共权限</span><br><span class="line">public:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;汽车  保护权限</span><br><span class="line">protected:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;银行卡密码  私有权限</span><br><span class="line">private:</span><br><span class="line">	int m_Password;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Name &#x3D; &quot;张三&quot;;</span><br><span class="line">		m_Car &#x3D; &quot;拖拉机&quot;;</span><br><span class="line">		m_Password &#x3D; 123456;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name &#x3D; &quot;李四&quot;;</span><br><span class="line">	&#x2F;&#x2F;p.m_Car &#x3D; &quot;奔驰&quot;;  &#x2F;&#x2F;保护权限类外访问不到</span><br><span class="line">	&#x2F;&#x2F;p.m_Password &#x3D; 123; &#x2F;&#x2F;私有权限类外访问不到</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h2>在C++中 struct和class唯一的区别就在于 默认的访问权限不同</li>
</ul>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class C1</span><br><span class="line">&#123;</span><br><span class="line">	int  m_A; &#x2F;&#x2F;默认是私有权限</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct C2</span><br><span class="line">&#123;</span><br><span class="line">	int m_A;  &#x2F;&#x2F;默认是公共权限</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A &#x3D; 10; &#x2F;&#x2F;错误，访问权限是私有</span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A &#x3D; 10; &#x2F;&#x2F;正确，访问权限是公共</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h2>优点1：将所有成员属性设置为私有，可以自己控制读写权限</li>
</ul>
<p>优点2：对于写权限，我们可以检测数据的有效性</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;姓名设置可读可写</span><br><span class="line">	void setName(string name) &#123;</span><br><span class="line">		m_Name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	string getName()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取年龄 </span><br><span class="line">	int getAge() &#123;</span><br><span class="line">		return m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;设置年龄</span><br><span class="line">	void setAge(int age) &#123;</span><br><span class="line">		if (age &lt; 0 || age &gt; 150) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;情人设置为只写</span><br><span class="line">	void setLover(string lover) &#123;</span><br><span class="line">		m_Lover &#x3D; lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	string m_Name; &#x2F;&#x2F;可读可写  姓名</span><br><span class="line">	</span><br><span class="line">	int m_Age; &#x2F;&#x2F;只读  年龄</span><br><span class="line"></span><br><span class="line">	string m_Lover; &#x2F;&#x2F;只写  情人</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	&#x2F;&#x2F;姓名设置</span><br><span class="line">	p.setName(&quot;张三&quot;);</span><br><span class="line">	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;年龄设置</span><br><span class="line">	p.setAge(50);</span><br><span class="line">	cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;情人设置</span><br><span class="line">	p.setLover(&quot;苍井&quot;);</span><br><span class="line">	&#x2F;&#x2F;cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  &#x2F;&#x2F;只写属性，不可以读取</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、对象的初始化和清理"><a href="#二、对象的初始化和清理" class="headerlink" title="二、对象的初始化和清理"></a>二、对象的初始化和清理</h1><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2>对象的初始化和清理也是两个非常重要的安全问题</li>
</ul>
<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p>
<p>编译器提供的构造函数和析构函数是空实现。</p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li>
</ul>
<p>构造函数语法：<code>类名()&#123;&#125;</code></p>
<ul>
<li><p>构造函数，没有返回值也不写void</p>
</li>
<li><p>函数名称与类名相同</p>
</li>
<li><p>构造函数可以有参数，因此可以发生重载</p>
</li>
<li><p>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： <code>~类名()&#123;&#125;</code></p>
</li>
<li><p>析构函数，没有返回值也不写void</p>
</li>
<li><p>函数名称与类名相同,在名称前加上符号 ~</p>
</li>
<li><p>析构函数不可以有参数，因此不可以发生重载</p>
</li>
<li><p>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;构造函数</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;析构函数</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><p>两种分类方式：</p>
<p>​ 按参数分为： 有参构造和无参构造</p>
<p>​ 按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​ 括号法</p>
<p>​ 显示法</p>
<p>​ 隐式转换法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、构造函数分类</span><br><span class="line">&#x2F;&#x2F; 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="line">&#x2F;&#x2F; 按照类型分类分为 普通构造和拷贝构造</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">	Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;有参构造函数</span><br><span class="line">	Person(int a) &#123;</span><br><span class="line">		age &#x3D; a;</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">	Person(const Person&amp; p) &#123;</span><br><span class="line">		age &#x3D; p.age;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;析构函数</span><br><span class="line">	~Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、构造函数的调用</span><br><span class="line">&#x2F;&#x2F;调用无参构造函数</span><br><span class="line">void test01() &#123;</span><br><span class="line">	Person p; &#x2F;&#x2F;调用无参构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用有参的构造函数</span><br><span class="line">void test02() &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2.1  括号法，常用</span><br><span class="line">	Person p1(10);</span><br><span class="line">	&#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="line">	&#x2F;&#x2F;Person p2();</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2.2 显式法</span><br><span class="line">	Person p2 &#x3D; Person(10); </span><br><span class="line">	Person p3 &#x3D; Person(p2);</span><br><span class="line">	&#x2F;&#x2F;Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2.3 隐式转换法</span><br><span class="line">	Person p4 &#x3D; 10; &#x2F;&#x2F; Person p4 &#x3D; Person(10); </span><br><span class="line">	Person p5 &#x3D; p4; &#x2F;&#x2F; Person p5 &#x3D; Person(p4); </span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="line">	&#x2F;&#x2F;Person p5(p4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line">	&#x2F;&#x2F;test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h2><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">		mAge &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(int age) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">		mAge &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(const Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">		mAge &#x3D; p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;析构函数在释放内存之前调用</span><br><span class="line">	~Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">void test01() &#123;</span><br><span class="line"></span><br><span class="line">	Person man(100); &#x2F;&#x2F;p对象已经创建完毕</span><br><span class="line">	Person newman(man); &#x2F;&#x2F;调用拷贝构造函数</span><br><span class="line">	Person newman2 &#x3D; man; &#x2F;&#x2F;拷贝构造</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;Person newman3;</span><br><span class="line">	&#x2F;&#x2F;newman3 &#x3D; man; &#x2F;&#x2F;不是调用拷贝构造函数，赋值操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 值传递的方式给函数参数传值</span><br><span class="line">&#x2F;&#x2F;相当于Person p1 &#x3D; p;</span><br><span class="line">void doWork(Person p1) &#123;&#125;</span><br><span class="line">void test02() &#123;</span><br><span class="line">	Person p; &#x2F;&#x2F;无参构造函数</span><br><span class="line">	doWork(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 以值方式返回局部对象</span><br><span class="line">Person doWork2()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	return p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">	Person p &#x3D; doWork2();</span><br><span class="line">	cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;test01();</span><br><span class="line">	&#x2F;&#x2F;test02();</span><br><span class="line">	test03();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">	Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;有参构造函数</span><br><span class="line">	Person(int a) &#123;</span><br><span class="line">		age &#x3D; a;</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">	Person(const Person&amp; p) &#123;</span><br><span class="line">		age &#x3D; p.age;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;析构函数</span><br><span class="line">	~Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(18);</span><br><span class="line">	&#x2F;&#x2F;如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span><br><span class="line">	Person p2(p1);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span><br><span class="line">	Person p1; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错</span><br><span class="line">	Person p2(10); &#x2F;&#x2F;用户提供的有参</span><br><span class="line">	Person p3(p2); &#x2F;&#x2F;此时如果用户没有提供拷贝构造，编译器会提供</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;如果用户提供拷贝构造，编译器不会提供其他构造函数</span><br><span class="line">	Person p4; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错</span><br><span class="line">	Person p5(10); &#x2F;&#x2F;此时如果用户自己没有提供有参，会出错</span><br><span class="line">	Person p6(p5); &#x2F;&#x2F;用户自己提供拷贝构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">	Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;有参构造函数</span><br><span class="line">	Person(int age ,int height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age &#x3D; age;</span><br><span class="line">		m_height &#x3D; new int(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;拷贝构造函数  </span><br><span class="line">	Person(const Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">		&#x2F;&#x2F;如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br><span class="line">		m_age &#x3D; p.m_age;</span><br><span class="line">		m_height &#x3D; new int(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;析构函数</span><br><span class="line">	~Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">		if (m_height !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_age;</span><br><span class="line">	int* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(18, 180);</span><br><span class="line"></span><br><span class="line">	Person p2(p1);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</code></p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>作用：</p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p>语法：<code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	传统方式初始化</span><br><span class="line">	&#x2F;&#x2F;Person(int a, int b, int c) &#123;</span><br><span class="line">	&#x2F;&#x2F;	m_A &#x3D; a;</span><br><span class="line">	&#x2F;&#x2F;	m_B &#x3D; b;</span><br><span class="line">	&#x2F;&#x2F;	m_C &#x3D; c;</span><br><span class="line">	&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;初始化列表方式初始化</span><br><span class="line">	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line">	void PrintPerson() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">	int m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	Person p(1, 2, 3);</span><br><span class="line">	p.PrintPerson();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Phone(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName &#x3D; name;</span><br><span class="line">		cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Phone()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;初始化列表可以告诉编译器调用哪一个构造函数</span><br><span class="line">	Person(string name, string pName) :m_Name(name), m_Phone(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void playGame()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;当类中成员是其他类对象时，我们称该成员为 对象成员</span><br><span class="line">	&#x2F;&#x2F;构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br><span class="line">	&#x2F;&#x2F;析构顺序与构造相反</span><br><span class="line">	Person p(&quot;张三&quot; , &quot;苹果X&quot;);</span><br><span class="line">	p.playGame();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<p>静态成员变量:</p>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化<br>静态成员函数:</li>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量<br>示例1 ：静态成员变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	static int m_A; &#x2F;&#x2F;静态成员变量</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;静态成员变量特点：</span><br><span class="line">	&#x2F;&#x2F;1 在编译阶段分配内存</span><br><span class="line">	&#x2F;&#x2F;2 类内声明，类外初始化</span><br><span class="line">	&#x2F;&#x2F;3 所有对象共享同一份数据</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	static int m_B; &#x2F;&#x2F;静态成员变量也是有访问权限的</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A &#x3D; 10;</span><br><span class="line">int Person::m_B &#x3D; 10;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;静态成员变量两种访问方式</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;1、通过对象</span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A &#x3D; 100;</span><br><span class="line">	cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A &#x3D; 200;</span><br><span class="line">	cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; &#x2F;&#x2F;共享同一份数据</span><br><span class="line">	cout &lt;&lt; &quot;p2.m_A &#x3D; &quot; &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2、通过类名</span><br><span class="line">	cout &lt;&lt; &quot;m_A &#x3D; &quot; &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;cout &lt;&lt; &quot;m_B &#x3D; &quot; &lt;&lt; Person::m_B &lt;&lt; endl; &#x2F;&#x2F;私有权限访问不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
示例2：静态成员函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;静态成员函数特点：</span><br><span class="line">	&#x2F;&#x2F;1 程序共享一个函数</span><br><span class="line">	&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量</span><br><span class="line">	</span><br><span class="line">	static void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;</span><br><span class="line">		m_A &#x3D; 100;</span><br><span class="line">		&#x2F;&#x2F;m_B &#x3D; 100; &#x2F;&#x2F;错误，不可以访问非静态成员变量</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static int m_A; &#x2F;&#x2F;静态成员变量</span><br><span class="line">	int m_B; &#x2F;&#x2F; </span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;静态成员函数也是有访问权限的</span><br><span class="line">	static void func2()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A &#x3D; 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;静态成员变量两种访问方式</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;1、通过对象</span><br><span class="line">	Person p1;</span><br><span class="line">	p1.func();</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2、通过类名</span><br><span class="line">	Person::func();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;Person::func2(); &#x2F;&#x2F;私有权限访问不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、C-对象模型和this指针"><a href="#三、C-对象模型和this指针" class="headerlink" title="三、C++对象模型和this指针"></a>三、C++对象模型和this指针</h1><h2 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h2>在C++中，类内的成员变量和成员函数分开存储</li>
</ul>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person() &#123;</span><br><span class="line">		mA &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;非静态成员变量占对象空间</span><br><span class="line">	int mA;</span><br><span class="line">	&#x2F;&#x2F;静态成员变量不占对象空间</span><br><span class="line">	static int mB; </span><br><span class="line">	&#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例</span><br><span class="line">	void func() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;静态成员函数也不占对象空间</span><br><span class="line">	static void sfunc() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; sizeof(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h2><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(int age)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="line">		this-&gt;age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; PersonAddPerson(Person p)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;age +&#x3D; p.age;</span><br><span class="line">		&#x2F;&#x2F;返回对象本身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(10);</span><br><span class="line">	cout &lt;&lt; &quot;p1.age &#x3D; &quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2(10);</span><br><span class="line">	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);</span><br><span class="line">	cout &lt;&lt; &quot;p2.age &#x3D; &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h2>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</li>
</ul>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;空指针访问成员函数</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	void ShowClassName() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void ShowPerson() &#123;</span><br><span class="line">		if (this &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person * p &#x3D; NULL;</span><br><span class="line">	p-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数</span><br><span class="line">	p-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h2><p>常函数：</p>
<ul>
<li><p>成员函数后加const后我们称为这个函数为常函数</p>
</li>
<li><p>常函数内不可以修改成员属性</p>
</li>
<li><p>成员属性声明时加关键字mutable后，在常函数中依然可以修改<br>常对象：</p>
</li>
<li><p>声明对象前加const称该对象为常对象</p>
</li>
<li><p>常对象只能调用常函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person() &#123;</span><br><span class="line">		m_A &#x3D; 0;</span><br><span class="line">		m_B &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;this指针的本质是一个指针常量，指针的指向不可修改</span><br><span class="line">	&#x2F;&#x2F;如果想让指针指向的值也不可以修改，需要声明常函数</span><br><span class="line">	void ShowPerson() const &#123;</span><br><span class="line">		&#x2F;&#x2F;const Type* const pointer;</span><br><span class="line">		&#x2F;&#x2F;this &#x3D; NULL; &#x2F;&#x2F;不能修改指针的指向 Person* const this;</span><br><span class="line">		&#x2F;&#x2F;this-&gt;mA &#x3D; 100; &#x2F;&#x2F;但是this指针指向的对象的数据是可以修改的</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br><span class="line">		this-&gt;m_B &#x3D; 100;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void MyFunc() const &#123;</span><br><span class="line">		&#x2F;&#x2F;mA &#x3D; 10000;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">	mutable int m_B; &#x2F;&#x2F;可修改 可变的</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const修饰对象  常对象</span><br><span class="line">void test01() &#123;</span><br><span class="line"></span><br><span class="line">	const Person person; &#x2F;&#x2F;常量对象  </span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;person.mA &#x3D; 100; &#x2F;&#x2F;常对象不能修改成员变量的值,但是可以访问</span><br><span class="line">	person.m_B &#x3D; 100; &#x2F;&#x2F;但是常对象可以修改mutable修饰成员变量</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;常对象访问成员函数</span><br><span class="line">	person.MyFunc(); &#x2F;&#x2F;常对象不能调用const的函数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、友元"><a href="#四、友元" class="headerlink" title="四、友元"></a>四、友元</h1></li>
</ul>
<p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为 friend</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h2 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">	friend void goodGay(Building * building);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Building()</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">		this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; &#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void goodGay(Building * building)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	goodGay(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend class goodGay;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">	building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	goodGay();</span><br><span class="line">	void visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">	void visit2(); </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br><span class="line">	friend void goodGay::visit();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">	building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit2()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、运算符重载"><a href="#五、运算符重载" class="headerlink" title="五、运算符重载"></a>五、运算符重载</h1><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h2 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h2><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person() &#123;&#125;;</span><br><span class="line">	Person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A &#x3D; a;</span><br><span class="line">		this-&gt;m_B &#x3D; b;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;成员函数实现 + 号运算符重载</span><br><span class="line">	Person operator+(const Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A &#x3D; this-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B &#x3D; this-&gt;m_B + p.m_B;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现 + 号运算符重载</span><br><span class="line">&#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="line">&#x2F;&#x2F;	Person temp(0, 0);</span><br><span class="line">&#x2F;&#x2F;	temp.m_A &#x3D; p1.m_A + p2.m_A;</span><br><span class="line">&#x2F;&#x2F;	temp.m_B &#x3D; p1.m_B + p2.m_B;</span><br><span class="line">&#x2F;&#x2F;	return temp;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运算符重载 可以发生函数重载 </span><br><span class="line">Person operator+(const Person&amp; p2, int val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A &#x3D; p2.m_A + val;</span><br><span class="line">	temp.m_B &#x3D; p2.m_B + val;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">	Person p1(10, 10);</span><br><span class="line">	Person p2(20, 20);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;成员函数方式</span><br><span class="line">	Person p3 &#x3D; p2 + p1;  &#x2F;&#x2F;相当于 p2.operaor+(p1)</span><br><span class="line">	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10)</span><br><span class="line">	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
<p>总结2：不要滥用运算符重载</p>
<h2 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h2><p>作用：可以输出自定义数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A &#x3D; a;</span><br><span class="line">		this-&gt;m_B &#x3D; b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="line">	&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">	&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现左移重载</span><br><span class="line">&#x2F;&#x2F;ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">	Person p1(10, 20);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
<h2 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h2><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line"></span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	MyInteger() &#123;</span><br><span class="line">		m_Num &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;前置++</span><br><span class="line">	MyInteger&amp; operator++() &#123;</span><br><span class="line">		&#x2F;&#x2F;先++</span><br><span class="line">		m_Num++;</span><br><span class="line">		&#x2F;&#x2F;再返回</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;后置++</span><br><span class="line">	MyInteger operator++(int) &#123;</span><br><span class="line">		&#x2F;&#x2F;先返回</span><br><span class="line">		MyInteger temp &#x3D; *this; &#x2F;&#x2F;记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span><br><span class="line">		m_Num++;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前置++ 先++ 再返回</span><br><span class="line">void test01() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后置++ 先返回 再++</span><br><span class="line">void test02() &#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line">	&#x2F;&#x2F;test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结： 前置递增返回引用，后置递增返回值</p>
<h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>c++编译器至少给一个类添加4个函数</p>
<ul>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(int age)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;将年龄数据开辟到堆区</span><br><span class="line">		m_Age &#x3D; new int(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;重载赋值运算符 </span><br><span class="line">	Person&amp; operator&#x3D;(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		if (m_Age !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;编译器提供的代码是浅拷贝</span><br><span class="line">		&#x2F;&#x2F;m_Age &#x3D; p.m_Age;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;提供深拷贝 解决浅拷贝的问题</span><br><span class="line">		m_Age &#x3D; new int(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;返回自身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		if (m_Age !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;年龄的指针</span><br><span class="line">	int *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(18);</span><br><span class="line"></span><br><span class="line">	Person p2(20);</span><br><span class="line"></span><br><span class="line">	Person p3(30);</span><br><span class="line"></span><br><span class="line">	p3 &#x3D; p2 &#x3D; p1; &#x2F;&#x2F;赋值操作</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;int a &#x3D; 10;</span><br><span class="line">	&#x2F;&#x2F;int b &#x3D; 20;</span><br><span class="line">	&#x2F;&#x2F;int c &#x3D; 30;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;c &#x3D; b &#x3D; a;</span><br><span class="line">	&#x2F;&#x2F;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h2><p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_Name &#x3D; name;</span><br><span class="line">		this-&gt;m_Age &#x3D; age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	bool operator&#x3D;&#x3D;(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator!&#x3D;(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;int a &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	Person a(&quot;孙悟空&quot;, 18);</span><br><span class="line">	Person b(&quot;孙悟空&quot;, 18);</span><br><span class="line"></span><br><span class="line">	if (a &#x3D;&#x3D; b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (a !&#x3D; b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h2><ul>
<li>函数调用运算符 () 也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class MyPrint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(string text)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;重载的（）操作符 也称为仿函数</span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	myFunc(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyAdd</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int operator()(int v1, int v2)</span><br><span class="line">	&#123;</span><br><span class="line">		return v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	int ret &#x3D; add(10, 10);</span><br><span class="line">	cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;匿名对象调用  </span><br><span class="line">	cout &lt;&lt; &quot;MyAdd()(100,100) &#x3D; &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h1>继承是面向对象三大特性之一</li>
</ul>
<p>有些类与类之间存在特殊的关系</p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h2 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h2><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p>普通实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Java页面</span><br><span class="line">class Java </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void header()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void footer()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void left()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void content()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;Python页面</span><br><span class="line">class Python</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void header()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void footer()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void left()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void content()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;C++页面</span><br><span class="line">class CPP </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void header()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void footer()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void left()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void content()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;Java页面</span><br><span class="line">	cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.header();</span><br><span class="line">	ja.footer();</span><br><span class="line">	ja.left();</span><br><span class="line">	ja.content();</span><br><span class="line">	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;Python页面</span><br><span class="line">	cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.header();</span><br><span class="line">	py.footer();</span><br><span class="line">	py.left();</span><br><span class="line">	py.content();</span><br><span class="line">	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;C++页面</span><br><span class="line">	cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.header();</span><br><span class="line">	cp.footer();</span><br><span class="line">	cp.left();</span><br><span class="line">	cp.content();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;公共页面</span><br><span class="line">class BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void header()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void footer()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void left()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Java页面</span><br><span class="line">class Java : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void content()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;Python页面</span><br><span class="line">class Python : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void content()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;C++页面</span><br><span class="line">class CPP : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void content()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;Java页面</span><br><span class="line">	cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.header();</span><br><span class="line">	ja.footer();</span><br><span class="line">	ja.left();</span><br><span class="line">	ja.content();</span><br><span class="line">	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;Python页面</span><br><span class="line">	cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.header();</span><br><span class="line">	py.footer();</span><br><span class="line">	py.left();</span><br><span class="line">	py.content();</span><br><span class="line">	cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;C++页面</span><br><span class="line">	cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.header();</span><br><span class="line">	cp.footer();</span><br><span class="line">	cp.left();</span><br><span class="line">	cp.content();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>继承的好处：可以减少重复的代码</p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p>派生类中的成员，包含两大部分：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p>继承的语法：<code>class 子类 : 继承方式 父类</code></p>
<p>继承方式一共有三种：</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public: </span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;公共继承</span><br><span class="line">class Son1 :public Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A; &#x2F;&#x2F;可访问 public权限</span><br><span class="line">		m_B; &#x2F;&#x2F;可访问 protected权限</span><br><span class="line">		&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void myClass()</span><br><span class="line">&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; &#x2F;&#x2F;其他类只能访问到公共权限</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保护继承</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_C;</span><br><span class="line">&#125;;</span><br><span class="line">class Son2:protected Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A; &#x2F;&#x2F;可访问 protected权限</span><br><span class="line">		m_B; &#x2F;&#x2F;可访问 protected权限</span><br><span class="line">		&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void myClass2()</span><br><span class="line">&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	&#x2F;&#x2F;s.m_A; &#x2F;&#x2F;不可访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;私有继承</span><br><span class="line">class Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_C;</span><br><span class="line">&#125;;</span><br><span class="line">class Son3:private Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A; &#x2F;&#x2F;可访问 private权限</span><br><span class="line">		m_B; &#x2F;&#x2F;可访问 private权限</span><br><span class="line">		&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class GrandSon3 :public Son3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span><br><span class="line">		&#x2F;&#x2F;m_A;</span><br><span class="line">		&#x2F;&#x2F;m_B;</span><br><span class="line">		&#x2F;&#x2F;m_C;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;公共继承</span><br><span class="line">class Son :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h2>子类继承父类后，当创建子类对象，也会调用父类的构造函数</li>
</ul>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Base </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Base()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Base()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Son()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Son()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h2 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h2><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li><p>访问子类同名成员 直接访问即可</p>
</li>
<li><p>访问父类同名成员 需要加作用域<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	Base()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A &#x3D; 100;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void func(int a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	Son()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A &#x3D; 200;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="line">	&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func();</span><br><span class="line">	s.Base::func(10);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
</li>
<li><p>子类对象可以直接访问到子类中同名成员</p>
</li>
<li><p>子类对象加作用域可以访问到父类同名成员</p>
</li>
<li><p>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p>
<h2 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h2><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
</li>
</ul>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static void func(int a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Base::m_A &#x3D; 100;</span><br><span class="line"></span><br><span class="line">class Son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Son::m_A &#x3D; 200;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同名成员属性</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;通过对象访问</span><br><span class="line">	cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;通过类名访问</span><br><span class="line">	cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同名成员函数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;通过对象访问</span><br><span class="line">	cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;</span><br><span class="line">	Son::func();</span><br><span class="line">	Son::Base::func();</span><br><span class="line">	&#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span><br><span class="line">	Son::Base::func(100);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;test01();</span><br><span class="line">	test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
<h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><p>C++允许一个类继承多个类</p>
<p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++实际开发中不建议用多继承</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Base1 &#123;</span><br><span class="line">public:</span><br><span class="line">	Base1()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A &#x3D; 100;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2 &#123;</span><br><span class="line">public:</span><br><span class="line">	Base2()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A &#x3D; 200;  &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><br><span class="line">class Son : public Base2, public Base1 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Son()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C &#x3D; 300;</span><br><span class="line">		m_D &#x3D; 400;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_C;</span><br><span class="line">	int m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多继承容易产生成员同名的情况</span><br><span class="line">&#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
<h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p>菱形继承概念：</p>
<p>​ 两个派生类继承同一个基类</p>
<p>​ 又有某个类同时继承者两个派生类</p>
<p>​ 这种继承被称为菱形继承，或者钻石继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;继承前加virtual关键字后，变为虚继承</span><br><span class="line">&#x2F;&#x2F;此时公共的父类Animal称为虚基类</span><br><span class="line">class Sheep : virtual public Animal &#123;&#125;;</span><br><span class="line">class Tuo   : virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep, public Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age &#x3D; 100;</span><br><span class="line">	st.Tuo::m_Age &#x3D; 200;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题<h1 id="七、多态"><a href="#七、多态" class="headerlink" title="七、多态"></a>七、多态</h1></li>
</ul>
<h2 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h2><p>多态是C++面向对象三大特性之一</p>
<p>多态分为两类</p>
<ul>
<li><p>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</p>
</li>
<li><p>动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p>
</li>
<li><p>静态多态的函数地址早绑定 - 编译阶段确定函数地址</p>
</li>
<li><p>动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;Speak函数就是虚函数</span><br><span class="line">	&#x2F;&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="line">	virtual void speak()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat :public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void speak()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog :public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	void speak()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="line">&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="line">&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编</span><br><span class="line"></span><br><span class="line">void DoSpeak(Animal &amp; animal)</span><br><span class="line">&#123;</span><br><span class="line">	animal.speak();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;多态满足条件： </span><br><span class="line">&#x2F;&#x2F;1、有继承关系</span><br><span class="line">&#x2F;&#x2F;2、子类重写父类中的虚函数</span><br><span class="line">&#x2F;&#x2F;多态使用：</span><br><span class="line">&#x2F;&#x2F;父类指针或引用指向子类对象</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	DoSpeak(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	DoSpeak(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
</li>
</ul>
<p>多态满足条件</p>
<ul>
<li><p>有继承关系</p>
</li>
<li><p>子类重写父类中的虚函数<br>多态使用条件</p>
</li>
<li><p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>
</li>
</ul>
<h2 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一-计算器类"></a>多态案例一-计算器类</h2><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通实现</span><br><span class="line">class Calculator &#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult(string oper)</span><br><span class="line">	&#123;</span><br><span class="line">		if (oper &#x3D;&#x3D; &quot;+&quot;) &#123;</span><br><span class="line">			return m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper &#x3D;&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">			return m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper &#x3D;&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">			return m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;如果要提供新的运算，需要修改源码</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_Num1;</span><br><span class="line">	int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;普通实现测试</span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 &#x3D; 10;</span><br><span class="line">	c.m_Num2 &#x3D; 10;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多态实现</span><br><span class="line">&#x2F;&#x2F;抽象计算器类</span><br><span class="line">&#x2F;&#x2F;多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="line">class AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line"></span><br><span class="line">	virtual int getResult()</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int m_Num1;</span><br><span class="line">	int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加法计算器</span><br><span class="line">class AddCalculator :public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;减法计算器</span><br><span class="line">class SubCalculator :public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;乘法计算器</span><br><span class="line">class MulCalculator :public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;创建加法计算器</span><br><span class="line">	AbstractCalculator *abc &#x3D; new AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 &#x3D; 10;</span><br><span class="line">	abc-&gt;m_Num2 &#x3D; 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;  &#x2F;&#x2F;用完了记得销毁</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建减法计算器</span><br><span class="line">	abc &#x3D; new SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 &#x3D; 10;</span><br><span class="line">	abc-&gt;m_Num2 &#x3D; 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;  </span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建乘法计算器</span><br><span class="line">	abc &#x3D; new MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 &#x3D; 10;</span><br><span class="line">	abc-&gt;m_Num2 &#x3D; 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;test01();</span><br><span class="line"></span><br><span class="line">	test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为抽象类<br>抽象类特点：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;纯虚函数</span><br><span class="line">	&#x2F;&#x2F;类中只要有一个纯虚函数就称为抽象类</span><br><span class="line">	&#x2F;&#x2F;抽象类无法实例化对象</span><br><span class="line">	&#x2F;&#x2F;子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="line">	virtual void func() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func() </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Base * base &#x3D; NULL;</span><br><span class="line">	&#x2F;&#x2F;base &#x3D; new Base; &#x2F;&#x2F; 错误，抽象类无法实例化对象</span><br><span class="line">	base &#x3D; new Son;</span><br><span class="line">	base-&gt;func();</span><br><span class="line">	delete base;&#x2F;&#x2F;记得销毁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多态案例二-制作饮品"><a href="#多态案例二-制作饮品" class="headerlink" title="多态案例二-制作饮品"></a>多态案例二-制作饮品</h2>案例描述：</li>
</ul>
<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象制作饮品</span><br><span class="line">class AbstractDrinking &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;烧水</span><br><span class="line">	virtual void Boil() &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;冲泡</span><br><span class="line">	virtual void Brew() &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;倒入杯中</span><br><span class="line">	virtual void PourInCup() &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;加入辅料</span><br><span class="line">	virtual void PutSomething() &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;规定流程</span><br><span class="line">	void MakeDrink() &#123;</span><br><span class="line">		Boil();</span><br><span class="line">		Brew();</span><br><span class="line">		PourInCup();</span><br><span class="line">		PutSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;制作咖啡</span><br><span class="line">class Coffee : public AbstractDrinking &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;烧水</span><br><span class="line">	virtual void Boil() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;冲泡</span><br><span class="line">	virtual void Brew() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;倒入杯中</span><br><span class="line">	virtual void PourInCup() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;加入辅料</span><br><span class="line">	virtual void PutSomething() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;制作茶水</span><br><span class="line">class Tea : public AbstractDrinking &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;烧水</span><br><span class="line">	virtual void Boil() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;冲泡</span><br><span class="line">	virtual void Brew() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;倒入杯中</span><br><span class="line">	virtual void PourInCup() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;加入辅料</span><br><span class="line">	virtual void PutSomething() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;业务函数</span><br><span class="line">void DoWork(AbstractDrinking* drink) &#123;</span><br><span class="line">	drink-&gt;MakeDrink();</span><br><span class="line">	delete drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">	DoWork(new Coffee);</span><br><span class="line">	cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;</span><br><span class="line">	DoWork(new Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li><p>可以解决父类指针释放子类对象</p>
</li>
<li><p>都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p>
</li>
<li><p>如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p>
</li>
</ul>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code>virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Animal()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak() &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">	&#x2F;&#x2F;virtual ~Animal()</span><br><span class="line">	&#x2F;&#x2F;&#123;</span><br><span class="line">	&#x2F;&#x2F;	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	virtual ~Animal() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><span class="line"></span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	Cat(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">		m_Name &#x3D; new string(name);</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Cat()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">		if (this-&gt;m_Name !&#x3D; NULL) &#123;</span><br><span class="line">			delete m_Name;</span><br><span class="line">			m_Name &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Animal *animal &#x3D; new Cat(&quot;Tom&quot;);</span><br><span class="line">	animal-&gt;Speak();</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="line">	&#x2F;&#x2F;怎么解决？给基类增加一个虚析构函数</span><br><span class="line">	&#x2F;&#x2F;虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="line">	delete animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>
<p>本章结束，感谢观看！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/28/C++%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/" rel="next" title="C++笔记-函数高级">
                <i class="fa fa-chevron-left"></i> C++笔记-函数高级
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/29/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="prev" title="C++笔记-文件操作">
                C++笔记-文件操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/yourname" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com/yourname" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B0%81%E8%A3%85"><span class="nav-number">1.</span> <span class="nav-text">一、封装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">封装的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct%E5%92%8Cclass%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">struct和class区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="nav-number">1.3.</span> <span class="nav-text">成员属性设置为私有</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">二、对象的初始化和清理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">构造函数和析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">构造函数的分类及调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">2.3.</span> <span class="nav-text">拷贝构造函数调用时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">2.4.</span> <span class="nav-text">构造函数调用规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.5.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">2.6.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">2.7.</span> <span class="nav-text">类对象作为类成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">2.8.</span> <span class="nav-text">静态成员</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="nav-number">3.</span> <span class="nav-text">三、C++对象模型和this指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="nav-number">3.1.</span> <span class="nav-text">成员变量和成员函数分开存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.</span> <span class="nav-text">this指针概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">空指针访问成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">const修饰成员函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8F%8B%E5%85%83"><span class="nav-number">4.</span> <span class="nav-text">四、友元</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">4.1.</span> <span class="nav-text">全局函数做友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">4.2.</span> <span class="nav-text">类做友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">4.3.</span> <span class="nav-text">成员函数做友元</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.</span> <span class="nav-text">五、运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.1.</span> <span class="nav-text">加号运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.2.</span> <span class="nav-text">左移运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.3.</span> <span class="nav-text">递增运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.4.</span> <span class="nav-text">赋值运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.5.</span> <span class="nav-text">关系运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.6.</span> <span class="nav-text">函数调用运算符重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF"><span class="nav-number">6.</span> <span class="nav-text">六、继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">继承的基本语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.</span> <span class="nav-text">继承中的对象模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">6.4.</span> <span class="nav-text">继承中构造和析构顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">6.5.</span> <span class="nav-text">继承同名成员处理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">6.6.</span> <span class="nav-text">继承同名静态成员处理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">6.7.</span> <span class="nav-text">多继承语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">6.8.</span> <span class="nav-text">菱形继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">7.</span> <span class="nav-text">七、多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.</span> <span class="nav-text">多态的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%B8%80-%E8%AE%A1%E7%AE%97%E5%99%A8%E7%B1%BB"><span class="nav-number">7.2.</span> <span class="nav-text">多态案例一-计算器类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">7.3.</span> <span class="nav-text">纯虚函数和抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%BA%8C-%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81"><span class="nav-number">7.4.</span> <span class="nav-text">多态案例二-制作饮品</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="nav-number">7.5.</span> <span class="nav-text">虚析构和纯虚析构</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">3rdman666</span>

  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>
-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
